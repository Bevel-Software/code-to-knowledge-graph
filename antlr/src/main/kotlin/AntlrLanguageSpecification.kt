package software.bevel.code_to_knowledge_graph.antlr

import org.antlr.v4.runtime.*
import software.bevel.graph_domain.graph.builder.DanglingNodeBuilder
import software.bevel.graph_domain.graph.builder.FullyQualifiedNodeBuilder
import software.bevel.graph_domain.graph.builder.GraphBuilder

/**
 * Defines a contract for language-specific ANTLR parsing configurations.
 * Implementations of this interface provide the necessary components (parser, lexer)
 * and logic to parse source code for a particular language using ANTLR.
 *
 * @param PARSER The type of the ANTLR `Parser` specific to the language.
 * @param LEXER The type of the ANTLR `Lexer` specific to the language.
 */
interface AntlrLanguageSpecification<PARSER: Parser, LEXER: Lexer> {
    /**
     * The default package name to be used if a package cannot be determined from the source code.
     * Defaults to "<default>".
     */
    val defaultPackageName: String
        get() = "<default>"

    /**
     * Determines whether a file with the given [fileName] should be parsed by this language specification.
     * This is typically based on file extensions or other naming conventions.
     *
     * @param fileName The name of the file to check.
     * @return `true` if the file should be parsed, `false` otherwise.
     */
    fun shouldParseFile(fileName: String): Boolean

    /**
     * Creates and returns a language-specific ANTLR parser instance for the given [input] token stream.
     *
     * @param input The [TokenStream] generated by the lexer.
     * @return An instance of the language-specific [PARSER].
     */
    fun getParser(input: TokenStream): PARSER

    /**
     * Creates and returns a language-specific ANTLR lexer instance for the given [input] character stream.
     *
     * @param input The [CharStream] representing the source code to be tokenized.
     * @return An instance of the language-specific [LEXER].
     */
    fun getLexer(input: CharStream): LEXER

    /**
     * Executes the top-level (entry) parsing rule for the language using the provided [parser].
     * This method should invoke the primary rule that represents the entire compilation unit (e.g., a file).
     *
     * @param parser The language-specific [PARSER] instance.
     * @return The [ParserRuleContext] representing the root of the parse tree generated from the top-level rule.
     */
    fun runTopLevelRule(parser: PARSER): ParserRuleContext

    /**
     * Attempts to resolve a [DanglingNodeBuilder] by searching for its fully qualified name within the import
     * statements present in the given [graph].
     * If a match is found, it may update the [nodesToReplace] map to indicate that the dangling node
     * can be replaced by the found fully qualified node.
     *
     * @param node The [DanglingNodeBuilder] to resolve.
     * @param graph The [GraphBuilder] containing the context, including import statements.
     * @param nodesToReplace A mutable map where UIDs of nodes to be replaced (keys) are mapped to UIDs of their replacements (values).
     *                       This map can be updated by this method if a resolution is found.
     * @return A [FullyQualifiedNodeBuilder] if the dangling node is successfully resolved through imports, `null` otherwise.
     */
    fun findFullyQualifiedNodeInImports(node: DanglingNodeBuilder, graph: GraphBuilder, nodesToReplace: MutableMap<String, String>): FullyQualifiedNodeBuilder?

}