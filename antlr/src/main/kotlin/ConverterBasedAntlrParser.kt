package software.bevel.code_to_knowledge_graph.antlr

import org.antlr.v4.runtime.CharStream
import org.antlr.v4.runtime.CharStreams
import org.antlr.v4.runtime.CommonTokenStream
import org.antlr.v4.runtime.atn.PredictionMode
import org.antlr.v4.runtime.tree.ParseTreeWalker
import org.slf4j.Logger
import org.slf4j.LoggerFactory
import org.snt.inmemantlr.listener.DefaultTreeListener
import org.snt.inmemantlr.listener.InmemantlrErrorListener
import org.snt.inmemantlr.tree.ParseTree
import software.bevel.graph_domain.*
import software.bevel.graph_domain.graph.Graphlike
import software.bevel.graph_domain.graph.builder.DanglingNodeBuilder
import software.bevel.graph_domain.graph.builder.GraphBuilder
import software.bevel.graph_domain.graph.builder.ImportStatement
import software.bevel.graph_domain.parsing.IntermediateFileParser
import software.bevel.graph_domain.parsing.IntermediateStringParser
import software.bevel.graph_domain.parsing.Parser
import java.io.File
import java.nio.file.Files
import java.nio.file.Paths
import java.nio.file.StandardOpenOption

/**
 * A parser implementation that utilizes ANTLR for syntactic analysis and a converter-based approach
 * via [AntlrTreeWalker] to transform parse trees into a [GraphBuilder] representation.
 * It relies on a [ConverterBasedAntlrLanguageSpecification] to provide language-specific
 * ANTLR parser/lexer instances and [AntlrTreeWalker.TreeToGraphConverter] rules.
 *
 * Implements [Parser] for general project parsing, [IntermediateFileParser] for single file parsing,
 * and [IntermediateStringParser] for parsing raw code strings.
 *
 * @param PARSER The type of the ANTLR `Parser` specific to the language.
 * @param LEXER The type of the ANTLR `Lexer` specific to the language.
 * @property languageSpecification The language-specific configuration providing ANTLR components and converters.
 * @property logger The logger instance used for recording parsing activities and potential issues.
 * @property augmenter The [GraphAugmenter] used to enhance and refine the constructed graph.
 */
class ConverterBasedAntlrParser<PARSER: org.antlr.v4.runtime.Parser, LEXER: org.antlr.v4.runtime.Lexer>(
    val languageSpecification: ConverterBasedAntlrLanguageSpecification<PARSER, LEXER>,
    override val logger: Logger = LoggerFactory.getLogger(ConverterBasedAntlrLanguageSpecification::class.java),
    private val augmenter: GraphAugmenter = GraphAugmenter(logger)
): Parser, IntermediateFileParser, IntermediateStringParser {
    /**
     * Stores a list of [ImportStatement]s encountered during the parsing of the current file or string.
     * This list is reset for each new file/string parsed and can be used by converters or augmentation steps.
     */
    private var fileImports: MutableList<ImportStatement> = mutableListOf()
    /**
     * The ANTLR [DefaultTreeListener] used to walk the parse tree generated by ANTLR.
     * It's configured to build a [ParseTree] representation.
     */
    val listener = DefaultTreeListener(true)

    /**
     * Recursively finds all files within the given [directory] that match the criteria defined
     * by [ConverterBasedAntlrLanguageSpecification.shouldParseFile].
     *
     * @param directory The root directory path to search for files.
     * @return A list of absolute file paths that are deemed parseable by the language specification.
     */
    private fun fileWalker(directory: String): List<String> {
        return Files.walk(Paths.get(directory))
            .filter { Files.isRegularFile(it) }
            .map { it.toString() }
            .filter { languageSpecification.shouldParseFile(it) }
            .toList()
    }

    /**
     * Parses one or more projects specified by [pathsToProjects] and returns a finalized [Graphlike] representation.
     * This involves collecting all parseable files, building an intermediate [GraphBuilder], augmenting it,
     * validating it, and finally building the immutable [Graphlike] structure.
     *
     * @param pathsToProjects A list of root directory paths for the projects to be parsed.
     * @return A [Graphlike] object representing the combined knowledge graph of the parsed projects.
     */
    override fun parse(pathsToProjects: List<String>): Graphlike {
        return parseToGraphBuilder(pathsToProjects).build(projectPath = pathsToProjects[0])
    }

    /**
     * Parses all parseable files within the specified [pathsToProjects] into a single [GraphBuilder].
     * It first collects all relevant files using [fileWalker]. It then calls `parseFiles` (whose definition
     * is not shown in this snippet but is assumed to process the list of files and return a merged graph)
     * to get an initial [GraphBuilder]. This graph is subsequently augmented, validated, and metrics are collected on it.
     *
     * @param pathsToProjects A list of root directory paths for the projects to be parsed.
     * @return A [GraphBuilder] containing the combined graph structure from all parsed files, after processing.
     */
    override fun parseToGraphBuilder(pathsToProjects: List<String>): GraphBuilder {
        val files = pathsToProjects.flatMap { fileWalker(it) }
        val mergedGraph = parseFiles(files)

        augmentGraph(mergedGraph)
        validateGraph(mergedGraph)
        Metrics.getMetrics(mergedGraph)
        return mergedGraph
    }

    /**
     * Validates the integrity of the given [graph] by checking for common issues.
     * Specifically, it iterates through all connections to ensure both source and target nodes exist in the graph.
     * It also identifies and logs any [DanglingNodeBuilder] instances that could not be fully qualified.
     *
     * @param graph The [GraphBuilder] instance to validate.
     */
    private fun validateGraph(graph: GraphBuilder) {
        graph.connectionsBuilder.getAllConnections().forEach { connection ->
            if (!graph.nodes.containsKey(connection.sourceNodeName) || !graph.nodes.containsKey(connection.targetNodeName)) {
                logger.error("Connection: $connection with sourceNode: ${connection.sourceNodeName} and targetNode: ${connection.targetNodeName} is invalid")
                if (graph.nodes.containsKey(connection.sourceNodeName)) {
                    logger.error("SourceNode: ${graph.nodes[connection.sourceNodeName]}")
                }
                if (graph.nodes.containsKey(connection.targetNodeName)) {
                    logger.error("TargetNode: ${graph.nodes[connection.targetNodeName]}")
                }
            }
        }
        graph.nodes.values.filterIsInstance<DanglingNodeBuilder>().forEach {
            logger.error("DanglingNodeBuilder ${it.id} could not be qualified")
        }
    }

    /**
     * Augments the provided [graph] by applying a series of enhancement steps using the [augmenter].
     * These steps include merging module nodes, adding default constructors, attempting to fully qualify
     * node names (resolving dangling nodes using imports), forcing qualification where possible,
     * and inferring module connections.
     *
     * @param graph The [GraphBuilder] to augment.
     */
    private fun augmentGraph(graph: GraphBuilder) {
        augmenter.mergeModuleNodes(graph)
        augmenter.addDefaultConstructor(graph)
        augmenter.fullyQualifyNodeNames(graph, languageSpecification::findFullyQualifiedNodeInImports)
        augmenter.forceQualify(graph)
        augmenter.inferModuleConnections(graph)
    }

    /**
     * Parses a single source code file specified by [absolutePathToFile].
     * It reads the file content and then delegates to [parseString] for the actual parsing logic.
     *
     * @param absolutePathToFile The absolute path to the source code file to be parsed.
     * @return A [GraphBuilder] representing the knowledge graph extracted from the file.
     */
    override fun parseFile(absolutePathToFile: String, initialGraph: GraphBuilder?): GraphBuilder {
        val codeFile = File(absolutePathToFile)
        return parseString(codeFile.readText(), absolutePathToFile, 0).let {
            initialGraph?.addAll(it)
            it
        }
    }

    /**
     * Parses a given [text] string containing source code.
     * This is the core parsing method that sets up the ANTLR lexer and parser, handles error listening,
     * invokes the top-level parsing rule defined by the [languageSpecification], and then uses
     * [AntlrTreeWalker.walk] with converters from the language specification to build an [AntlrGraphBuilder].
     * Import statements found are stored in [fileImports] and associated with any [DanglingNodeBuilder]s.
     *
     * @param text The source code content as a string.
     * @param filePath The original file path associated with this text (used for context, e.g., by converters).
     * @param startIndex An integer offset for generating unique IDs, typically 0 for standalone parsing.
     * @return An [AntlrGraphBuilder] containing the graph structure derived from the parsed text.
     * @throws Exception if the ANTLR parse tree ([pt]) cannot be generated.
     */
    override fun parseString(text: String, filePath: String, startIndex: Int): GraphBuilder {
        fileImports = mutableListOf()
        listener.reset()
        val charStream: CharStream = CharStreams.fromString(text)
        val lexer = languageSpecification.getLexer(charStream)
        val el: InmemantlrErrorListener = InmemantlrErrorListener()
        lexer.addErrorListener(el)
        val tokens: CommonTokenStream = CommonTokenStream(lexer)
        val parser = languageSpecification.getParser(tokens)
        listener.setParser(parser)
        //parser.addParseListener(DefaultListener())
        parser.addErrorListener(el)
        parser.interpreter.predictionMode = PredictionMode.LL
        parser.buildParseTree = true
        parser.tokenStream = tokens

        val data = languageSpecification.runTopLevelRule(parser)
        ParseTreeWalker.DEFAULT.walk(listener, data)

        parser.removeParseListeners()
        parser.removeErrorListeners()

        val pt: ParseTree? = listener.parseTree

        val converters = languageSpecification.declareConverters(filePath, fileImports, startIndex)

        val graph = pt?.let { AntlrTreeWalker.walk(it, converters, languageSpecification.defaultPackageName, AntlrGraphBuilder(projectPath = filePath)) } ?: throw Exception("Failed to parse file")

        graph.nodes.values.filterIsInstance<DanglingNodeBuilder>().forEach { node ->
            node.importStatements = fileImports
        }

        return graph
    }

    /**
     * A utility method to serialize an ANTLR [ParseTree] to a JSON string and write it to a specified file.
     * Useful for debugging the structure of the parse tree generated by ANTLR.
     *
     * @param pt The [ParseTree] to serialize.
     * @param pathToFile The file path where the JSON output will be saved. Defaults to ".\\output\\output.json".
     */
    private fun printTreeToFile(pt: ParseTree, pathToFile: String = ".\\output\\output.json") {
        val content: String = pt.toJson()
        Files.write(
            Paths.get(pathToFile),
            content.toByteArray(),
            StandardOpenOption.CREATE,
            StandardOpenOption.TRUNCATE_EXISTING
        )
    }
}