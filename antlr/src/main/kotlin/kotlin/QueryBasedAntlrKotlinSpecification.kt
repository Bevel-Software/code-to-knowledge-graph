package software.bevel.code_to_knowledge_graph.antlr.kotlin

import org.antlr.v4.runtime.CharStream
import org.antlr.v4.runtime.ParserRuleContext
import org.antlr.v4.runtime.TokenStream
import software.bevel.code_to_knowledge_graph.antlr.GraphAugmenter
import software.bevel.graph_domain.graph.builder.DanglingNodeBuilder
import software.bevel.graph_domain.graph.builder.FullyQualifiedNodeBuilder
import software.bevel.graph_domain.graph.builder.GraphBuilder
import software.bevel.code_to_knowledge_graph.antlr.KotlinLexer
import software.bevel.code_to_knowledge_graph.antlr.KotlinParser
import software.bevel.code_to_knowledge_graph.antlr.QueryBasedAntlrLanguageSpecification
import software.bevel.code_to_knowledge_graph.antlr.bevel_ast_ql.QueryNode
import software.bevel.code_to_knowledge_graph.antlr.bevel_ast_ql.QueryParser

/**
 * Implements [QueryBasedAntlrLanguageSpecification] for the Kotlin programming language.
 * This class provides the necessary configurations for parsing Kotlin files using ANTLR Kotlin grammar
 * and a set of predefined YAML queries to extract structural information into a knowledge graph.
 *
 * @property graphAugmenter An optional [GraphAugmenter] instance used to perform additional
 *                          modifications or enhancements to the graph after the initial query-based parsing.
 */
open class QueryBasedAntlrKotlinSpecification(
    /**
     * The [GraphAugmenter] instance to use for augmenting the graph.
     * Defaults to a new instance of [GraphAugmenter] if not provided.
     */
    val graphAugmenter: GraphAugmenter = GraphAugmenter()
): QueryBasedAntlrLanguageSpecification<KotlinParser, KotlinLexer> {
    /**
     * The base identifier name used in Kotlin grammar, typically "simpleIdentifier".
     * This is used by the query engine to identify named elements.
     */
    override val baseIdentifierName: String?
        get() = "simpleIdentifier"

    /**
     * Determines if a file should be parsed based on its name.
     * For Kotlin, this checks for the ".kt" extension and excludes files in "resources" directories.
     *
     * @param fileName The name of the file to check.
     * @return `true` if the file should be parsed, `false` otherwise.
     */
    override fun shouldParseFile(fileName: String): Boolean {
        return fileName.endsWith(".kt") && !fileName.contains("/resources/") && !fileName.contains("\\resources\\")
    }

    /**
     * Creates and returns a [KotlinParser] instance for the given token stream.
     *
     * @param input The [TokenStream] generated by the lexer.
     * @return A new [KotlinParser] instance.
     */
    override fun getParser(input: TokenStream): KotlinParser = KotlinParser(input)

    /**
     * Creates and returns a [KotlinLexer] instance for the given character stream.
     *
     * @param input The [CharStream] representing the content of a Kotlin file.
     * @return A new [KotlinLexer] instance.
     */
    override fun getLexer(input: CharStream): KotlinLexer = KotlinLexer(input)

    /**
     * Loads and returns a list of Kotlin specific query patterns from YAML files.
     * These patterns define how different Kotlin language constructs (classes, functions, properties, etc.)
     * are identified and mapped to graph nodes and relationships.
     *
     * @return A list of [QueryNode.PatternMetadata] parsed from Kotlin query YAML files.
     * @throws IllegalStateException if any of the specified query files cannot be read.
     */
    override fun getPatterns(): List<QueryNode.PatternMetadata> {
        val queryFiles = listOf(
            "/queries/kotlin/KotlinClassQuery.yaml",
            "/queries/kotlin/KotlinPackageQuery.yaml",
            "/queries/kotlin/KotlinImportQuery.yaml",
            "/queries/kotlin/KotlinTypeQuery.yaml",
            "/queries/kotlin/KotlinFunctionQuery.yaml",
            "/queries/kotlin/KotlinPropertyQuery.yaml",
            "/queries/kotlin/KotlinObjectQuery.yaml",
            "/queries/kotlin/KotlinConstructorQuery.yaml",
            "/queries/kotlin/KotlinTypeAliasQuery.yaml",
            "/queries/kotlin/KotlinCallQuery.yaml",
        )
        
        return queryFiles.flatMap { queryFile ->
            val queryContent = this::class.java.getResourceAsStream(queryFile)?.bufferedReader()?.readText()
                ?: throw IllegalStateException("Could not read query file: $queryFile")
            QueryParser.parse(queryContent)
        }
    }

    /**
     * Specifies the root rule of the Kotlin ANTLR grammar to start parsing from.
     * For Kotlin, this is the `kotlinFile` rule.
     *
     * @param parser The [KotlinParser] instance.
     * @return The [ParserRuleContext] corresponding to the `kotlinFile` rule.
     */
    override fun runTopLevelRule(parser: KotlinParser): ParserRuleContext = parser.kotlinFile()

    /**
     * Attempts to find a fully qualified node corresponding to a dangling node by checking the import statements.
     * This method is crucial for resolving types and other references that might be imported from other packages or files.
     *
     * @param node The [DanglingNodeBuilder] representing an unresolved node.
     * @param graph The current [GraphBuilder] instance containing the graph being built.
     * @param nodesToReplace A mutable map used to track nodes that have been resolved and should be replaced.
     *                       The key is the ID of the dangling node, and the value is the ID of the resolved fully qualified node.
     * @return The [FullyQualifiedNodeBuilder] if the dangling node is successfully resolved through an import, otherwise `null`.
     */
    override fun findFullyQualifiedNodeInImports(node: DanglingNodeBuilder, graph: GraphBuilder, nodesToReplace: MutableMap<String, String>): FullyQualifiedNodeBuilder? {
        //logger.info("Looking for fully qualified node in imports: ${node.name}")
        for (importStatement in node.importStatements) {
            val importName = importStatement.importedPackage
            // Check if the import directly imports the class
            if (importName.endsWith(".${node.id}")) {
                val fqNode = graph.nodes.values.find {
                    it is FullyQualifiedNodeBuilder && it.id == importName
                }
                if (fqNode != null && fqNode is FullyQualifiedNodeBuilder) {
                    return fqNode
                } else {
                    graphAugmenter.qualifyNode(node, importName, graph, nodesToReplace)
                }
            } else if (importName.endsWith(".*")) {
                // Handle wildcard imports
                val packageName = importName.removeSuffix(".*")
                val fqNode = graph.nodes.values.find {
                    it is FullyQualifiedNodeBuilder && it.id == "$packageName.${node.id}"
                }
                if (fqNode != null && fqNode is FullyQualifiedNodeBuilder) {
                    return fqNode
                }

                // Check child nodes of the imported package or class
                val parentNode = graph.nodes.values.find {
                    it is FullyQualifiedNodeBuilder && it.id == packageName
                }
                if (parentNode != null && parentNode is FullyQualifiedNodeBuilder) {
                    val childNode = graph.getChildren(parentNode.id).find { it is FullyQualifiedNodeBuilder && it.id.endsWith(".${node.id}") }
                    if (childNode is FullyQualifiedNodeBuilder) {
                        return childNode
                    }
                }
            }
        }
        return null
    }
}