package software.bevel.code_to_knowledge_graph.antlr.csharp

import org.antlr.v4.runtime.CharStream
import org.antlr.v4.runtime.ParserRuleContext
import org.antlr.v4.runtime.TokenStream
import software.bevel.graph_domain.graph.builder.DanglingNodeBuilder
import software.bevel.graph_domain.graph.builder.FullyQualifiedNodeBuilder
import software.bevel.graph_domain.graph.builder.GraphBuilder
import software.bevel.code_to_knowledge_graph.antlr.CSharpLexer
import software.bevel.code_to_knowledge_graph.antlr.CSharpParser
import software.bevel.code_to_knowledge_graph.antlr.GraphAugmenter
import software.bevel.code_to_knowledge_graph.antlr.QueryBasedAntlrLanguageSpecification
import software.bevel.code_to_knowledge_graph.antlr.bevel_ast_ql.QueryNode
import software.bevel.code_to_knowledge_graph.antlr.bevel_ast_ql.QueryParser

/**
 * Implements [QueryBasedAntlrLanguageSpecification] for the C# programming language.
 * This class provides the necessary configurations for parsing C# files using ANTLR C# grammar
 * and a set of predefined YAML queries to extract structural information into a knowledge graph.
 *
 * @property graphAugmenter An optional [GraphAugmenter] instance used to perform additional
 *                          modifications or enhancements to the graph after the initial query-based parsing.
 */
class QueryBasedAntlrCSharpSpecification(
    val graphAugmenter: GraphAugmenter = GraphAugmenter()
): QueryBasedAntlrLanguageSpecification<CSharpParser, CSharpLexer> {

    /**
     * Loads and returns a list of C# specific query patterns from YAML files.
     * These patterns define how different C# language constructs (namespaces, classes, methods, etc.)
     * are identified and mapped to graph nodes and relationships.
     *
     * @return A list of [QueryNode.PatternMetadata] parsed from C# query YAML files.
     * @throws IllegalStateException if any of the specified query files cannot be read.
     */
    override fun getPatterns(): List<QueryNode.PatternMetadata> {
        val queryFiles = listOf(
            "/queries/csharp/CSharpNamespaceQuery.yaml",
            "/queries/csharp/CSharpCallQuery.yaml",
            "/queries/csharp/CSharpClassQuery.yaml",
            "/queries/csharp/CSharpConstructorQuery.yaml",
            "/queries/csharp/CSharpFunctionQuery.yaml",
            "/queries/csharp/CSharpImportQuery.yaml",
            "/queries/csharp/CSharpObjectQuery.yaml",
            "/queries/csharp/CSharpPropertyQuery.yaml",
            "/queries/csharp/CSharpTypeQuery.yaml",
            "/queries/csharp/CSharpDelegateAndEventQuery.yaml",
            "/queries/csharp/CSharpEnumQuery.yaml",
            "/queries/csharp/CSharpOperatorQuery.yaml",
        )

        return queryFiles.flatMap { queryFile ->
            val queryContent = this::class.java.getResourceAsStream(queryFile)?.bufferedReader()?.readText()
                ?: throw IllegalStateException("Could not read query file: $queryFile")
            QueryParser.parse(queryContent)
        }
    }

    /**
     * Determines if a file should be parsed based on its name.
     * For C#, this typically means checking for the ".cs" extension.
     *
     * @param fileName The name of the file to check.
     * @return `true` if the file has a ".cs" extension, `false` otherwise.
     */
    override fun shouldParseFile(fileName: String): Boolean {
        return fileName.endsWith(".cs")
    }

    /**
     * Creates and returns a [CSharpParser] instance for the given token stream.
     *
     * @param input The [TokenStream] generated by the lexer.
     * @return A new [CSharpParser] instance.
     */
    override fun getParser(input: TokenStream): CSharpParser {
        return CSharpParser(input)
    }

    /**
     * Creates and returns a [CSharpLexer] instance for the given character stream.
     *
     * @param input The [CharStream] representing the content of a C# file.
     * @return A new [CSharpLexer] instance.
     */
    override fun getLexer(input: CharStream): CSharpLexer {
        return CSharpLexer(input)
    }

    /**
     * Specifies the root rule of the C# ANTLR grammar to start parsing from.
     * For C#, this is typically the `compilation_unit` rule.
     *
     * @param parser The [CSharpParser] instance.
     * @return The [ParserRuleContext] corresponding to the `compilation_unit` rule.
     */
    override fun runTopLevelRule(parser: CSharpParser): ParserRuleContext {
        return parser.compilation_unit()
    }

    /**
     * Finds a fully qualified node in the imports of a given node.
     * This method is used to resolve the fully qualified name of a node based on its imports.
     *
     * @param node The [DanglingNodeBuilder] instance to find the fully qualified node for.
     * @param graph The [GraphBuilder] instance representing the knowledge graph.
     * @param nodesToReplace A map linking node IDs to their corresponding fully qualified node IDs.
     * @return The fully qualified node if found, or `null` otherwise.
     */
    override fun findFullyQualifiedNodeInImports(node: DanglingNodeBuilder, graph: GraphBuilder, nodesToReplace: MutableMap<String, String>): FullyQualifiedNodeBuilder? {
        //logger.info("Looking for fully qualified node in imports: ${node.name}")
        for (importStatement in node.importStatements) {
            val importName = importStatement.importedPackage
            // Check if the import directly imports the class
            if (importName.endsWith(".${node.id}")) {
                val fqNode = graph.nodes.values.find {
                    it is FullyQualifiedNodeBuilder && it.id == importName
                }
                if (fqNode != null && fqNode is FullyQualifiedNodeBuilder) {
                    return fqNode
                } else {
                    graphAugmenter.qualifyNode(node, importName, graph, nodesToReplace)
                }
            } else {
                val fqNode = graph.nodes.values.find {
                    it is FullyQualifiedNodeBuilder && it.id == "$importName.${node.id}"
                }
                if (fqNode != null && fqNode is FullyQualifiedNodeBuilder) {
                    return fqNode
                }

                // Check child nodes of the imported package or class
                val parentNode = graph.nodes.values.find {
                    it is FullyQualifiedNodeBuilder && it.id == importName
                }
                if (parentNode != null && parentNode is FullyQualifiedNodeBuilder) {
                    val childNode = graph.getChildren(parentNode.id).find { it is FullyQualifiedNodeBuilder && it.id.endsWith(".${node.id}") }
                    if (childNode is FullyQualifiedNodeBuilder) {
                        return childNode
                    }
                }
            }
        }
        return null
    }

}